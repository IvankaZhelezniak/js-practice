// Бывают такие ситуации когда нужно просто в переменную по условию записать
// разные значения

// Пример с возрастом

// let category;
// const age = 16;

// if (age >= 18) {
//     category = 'adult';
// } else {
//     category = 'child';
// }

// console.log(category);

// Для такой операции писать if...else излишнее, но это не значит что это не правильно - но излишне.
// Можно использовать Тернарный оператор

// ТЕРНАРНЫЙ ОПЕРАТОР - это просто сокращенная запись if...else, и используется
// этот Тернарный оператор только в случае когда нужно в переменную 
// по условию что - то записать.
// Нивкоем случае он не заменяет if...else для каких-то сложных операций 
// когда внутри много кода
// используется только тогда когда по условию в переменную нужно записать 2 значения - все.

// Как работает ТЕРНАРНЫЙ ОПЕРАТОР

// const age = 20;
// если условие выполняется true (оно истинно) то на место всего выражения 
// станет значение1
// если это условие не выполняется то значение2 будет

// const category = условие ? значение1 : значение2;

// const category = age >= 18 ? 'adult' : 'child';
// console.log(category);





// Инструкция switch
// Используем если просто применяется равенство ===
// Выберем сколько звезд в отеле

// const stars = 3;

// if (stars === 1) {
//     console.log('1');
// } else if (stars === 2) {
//     console.log('2');
// } else if (stars === 3) {
//     console.log('3');
// } else if (stars === 4) {
//     console.log('4');
// } else if (stars === 5) {
//     console.log('5');
// } else {
//     console.log('Ничего не найдено');
// }

// Пишем аналог вот этому и используем switch
// break - прерывает исполнения конструкцый что-бы дальше не проверялось если условие выполено

// switch делает только на равенство === ( на больше менше нельзя)
// switch - это сравнение с множественным количеством значений 
// тоесть много вариантов значений не > и не < а именно равно ===

// const stars = 6;
// let result;

// switch (stars) {
//     case 1:
//         result = 'case 1';
//         break;
    
//     case 2:
//         result = 'case 2';
//         break;
    
//     case 3:
//         result = 'case 3';
//         break;
    
//     case 4:
//         result = 'case 4';
//         break;
    
//     case 5:
//         result = 'case 5';
//         break;
    
//     default:
//         result = 'Неверный ввод';
// }

// console.log(result);


// Еще один пример по switch
// Выбираем стоимость готеля по звездам

// const stars = 5;
// let price = 0;

// switch (stars) {
//     case 1:
//         price = 20;
//         break;
    
//     case 2:
//     case 3:
//     case 4:
//         price = 50;
//         break;
//     case 5:
//         price = 100;
//         break;
    
//     default:
//         console.log('Такого кол-ва звезд нет');
// }

// console.log(price);






// Знакомство с ЦИКЛАМИ

// Цикл - это синтаксическая конструкция которая позволяет нам в коде выполнить
// какой-то кусочек несколько раз. 

// Представим что нам надо вывести в консоль числа от 1 до 5.
// Берем

// console.log(1);
// console.log(2);
// console.log(3);
// console.log(4);
// console.log(5);

// А что мы сделаем если надо вывести от 1 до 50???
// когда необходимо повторить какую нибудь операцыю несколько раз, мы можем
// использовать циклы. - это обычная управляющая конструкцыя.

// ЦЫКЛ  for (перевод - ЗА) - позволяет несколько раз (или n-нное кол-во раз)
// выполнить свое тело.

// Пишется так:  for(сюда пишем условие) {это тело}
// У большинства констркукций есть тело: у if...else есть тело, у switch есть тело,
// у for есть тело которое делает блочную область видимости.

// 1))))   Инициализация (initialization) - это буквально счетчик, тоесть мы говорим с 
// какого шага начать 1,2,3,4,5
// let count = 0;  - тоесть мой счетчик будет начинатся с нуля

// for (initialization; condition; post-expression) {
  // statements
// }

// 2))))  condition (условие) - это то условие, при котором необходимо цикл прервать.
// Если мы не укажем условие - то цикл никогда не остановится, он будет бесконечным и 
// вкладка браузера полностью зависнет
// Пока true цикл будет работать, когда false прекращается
// count < 5; если менше 5 работает, если больше или равен 5 цыкл моментально прервется

// 3))))  Инкремент - это то насколько мы хотим на каждой итерации (на каждом шаге)
// увеличить наш счетчик на +1

// count += 1 - увеличиваем на 1 если count = 0; тоесть было бы так count = count + 1



// for (let count = 0; count < 5; count += 1) {
//     console.log(count);
// }



// for (let i = 10; i > 0; i -= 1) {
//     console.log(`i ${i}`);
// }



// const target = 3;
// let sum = 0;

// for (let i = 0; i <= target; i += 1) {
//   sum += i;
// }

// console.log(sum);



// const max = 10;

// for (let i = 0; i < max; i += 1) {
//   console.log(i);
// }



// Часто всего цыкли используются с масивами - это такие наборы данных.
// Теперь мы можем использовать, например мы можем спросить пользователя: 
// - Введите число
// После чего нам надо взять это число и посчитать сумму всех его составляющих
// Например если 5 ввел то нам надо посчитать 5+4+3+2+1 (додать все числа которые ниже 5)


// const number = 3;
// let total = 0;

// for (let i = 1; i <= number; i += 1) {
//     total += i;
// }

// console.log(`Total = ${total}`);

// Будет 6 потому что 3+2+1=6

// Теперь мы можем использовать, например мы можем спросить пользователя: 
// - Введите число


// let userInput = prompt('Введите число');
// userInput = Number(userInput);
// let total = 0;

// for (let i = 1; i <= userInput; i += 1) {
//     total += i;
// }

// console.log(`Total = ${total}`);


// Цыкл for будем использовать часто при обучениии и иногда в работе






// Цыкли while и do...while - о них просто нужно знать (класические циклы)

// Цыкл while - ДО ТЕХ ПОР ПОКА (так читается)


// while (условие condition) {statements - тело} - условия которые мы напишем в этих
// скобках() while будет выполнять тело {} до тех пор пока это условие истинно true
// тут очень важно что-бы не сделать бесконечный цыкл, тоесть если я напишу
// while (5 > 2) {} - это будет бесконечный цыкл, это тело {} будет выполнятся
// всегда, и у нас просто зависнет наша вкладка и никогда не отвиснет

// for более современный, while более старый , но нужно знать

// Тут нужен счетчик 'i', у for можна счетчик сделать прямо в теле внутри, а тут его
// прийдется обьявлять руками



// const number = 5;
// let total = 0;
// let i = 1;

// while (i <= number) {
//     total += i;

//     i += 1;
// }

// console.log(`Total = ${total}`);



// Мы должны понимать когда
// i = 1;
// total 0 + 1 = 1

// Следующая итерацыя
// i = 2;
// total 1 + 2 = 3

// И увеличивается щетчик на 1  i += 1
// i = 3;
// total 3 + 3 = 6

// Потом i = 4;  условия не выполняются и записывается последний результат Total = 6



// const number = 5;
// let total = 0;
// let i = 1;

// while (i <= number) {
//     total += i;

//     i += 1;
// }

// console.log(`Total = ${total}`);



//  Читается это так - до тех пор пока i <= 5 мы выполняем это тело {total += i},
//  А ГДЕ увеличивается наш счетчик??? Это тоже надо делать руками, тоесть
// i += 1; for это делает просто удобнее, сразу в подписи этого цыкла

// While (более низкоуровневый) быстрее чем for работает

// А ЧТО ЕСЛИ МЫ СДЕЛАЕМ ВОТ ТАК  let i = 10;  Будет Total = 0;
// Из - за того что счетчик i = 10; больше чем изначальное число number = 5; - 
// тоесть false  у нас ни разу не выполнилось тело {}


// const number = 5;
// let total = 0;
// let i = 10;

// while (i <= number) {
//     total += i;

//     i += 1;
// }

// console.log(`Total = ${total}`);





// Что если нам еобходимо что-бы тело выполнилось хотя бы один раз

// Задача следующая

// Просим пользователя что-то ввести в promt допустим число равное чему-то
// const userInput = prompt('Введи 5');
// и нам необходимо спрашивать его до тех пор пока он не введет эту 5-ку
// ну ок, while - до тех пор,  А ДО КАКИХ ПОР МЫ будем это проверять?
// Во первых: нам promt нужно делать внутри цыкла, получается нам надо сделать
// какое-то такое условие что-бы хотя бы один раз выполнился этот prompt('Введи 5');

// Надо придумывать условия ()
// Для того что-бы хотя бы один раз выполнить тело {} перед проверкой условия 
// используется do while - сделай что-то до тех пор пока


// do while - СДЕЛАЙ ЧТО-ТО ДО ТЕХ ПОР ПОКА

// let userInput;

// do {
//     userInput = prompt('Введи 5');
//     userInput = Number(userInput);
// } while (userInput !== 5);

// Вот это выполнится хотя бы 1 раз и потом делай до тех пор пока не выполнится это 
// условие (userInput !== 5);





// Как это работает нужны дополнительные переменные:  Варианта 2:
// 1 - или писать какое-то сложное условия
// 2 - или прервать цыкл при каком то условии

//  Я прошу пользователя что-то ввести userInput = prompt('Введи 5');
// а потом если (if)  userInput === null мы делаем break (прерываем)

// Давайте подумаем: Запускается скрипт, выпадает нам вот это userInput = prompt('Введи 5');
// тоесть promt, я нажымаю cancel или отмена по руски
// если нажму cancel все класно выполняется вото эта строка кода 
//  if(userInput === null) {
        // break;
    // }

// Он проверяет userInput === null? Если я нажму cancel то сюда userInput
// записался null, это приводтся к true (истина верно) выполняется тело if и break
// break - прерывает исполнение цыкла

// promt возвращает null когда мы нажали cancel
// или значение когда мы нажали ок



// let userInput;

// do {
//     userInput = prompt('Введи 5');

//     if(userInput === null) {
//         break;
//     }
//     userInput = Number(userInput);
// } while (userInput !== 5);


// МЫ НИКОГДА НЕ БУДЕМ ИСПОЛЬЗОВАТЬ НИ promt 







// Инструкция continue

// for (let i = 0; i < 5; i += 1) {
//     console.log(i);
// }


// А почему не используете i++?? - это недекларативный код, не явная операцыя
// Есть такое пост-икремент, пост-дикремент

// i++ правильно заменять i += 1
// Используются линтеры - анализатор кода, и есть какие -то лучшие практики
// На работе такое i++ просто не пропускают

// Линт - это анализатор кода -  eslint.org

// Не пропускат унарный +('5') -  превращает строку в number, на работе скажут иди
// сделай по другому

// i++ правильно заменять i += 1




// Инструкция continue

// for (let i = 0; i < 5; i += 1) {
//     console.log(i);
// }



// Как нам вывести только четные? Теоретически я могу просто увеличивать на 2 (i += 2)
// я получу только четные

// Увеличивать шаг можна не только на 1, но и на 2 на 10 на миллион на сколько хотим


// Например у нас задание увеливать на 1 (i += 1) 
// и надо вывести только четные числа
// Есть ОПЕРАЦЫЯ ОСТАТОК ОТ ДЕЛЕНИЯ  console.log(5 % 2); - тоесть 2 влезает 1 невлезает

// Выведет ЧЕТНЫЕ ЧИСЛА


// for (let i = 0; i < 10; i += 1) {

//     if (i % 2 === 0) {
//         console.log(i);
//     }
// }


// Выведет все НЕЧЕТНЫЕ ЧИСЛА


// for (let i = 0; i < 10; i += 1) {

//     if (i % 2 === 0) {
//         continue;
//     }

//     console.log(i);
// }


// break - прерывает цыклы
// continue - прерывает текущую только итерацыю

// когда допустим i = 2 (тогда 2/2) остаток от деления будет 0, и continue 
// это значит что закончить текущую итерацию, больше не выполнять это тело на текущей
// итерации. иди на следующую. И мы видим только НЕЧЕТНЫЕ ЧИСЛА



//  В будущем будет использовать for и break для того что-бы найти в массиве
// елемента какую-то штуку, например у нас есть массив - колекция имен и нам 
// нужно посмотреть есть в этой колекциии такое-то имя. Ищите, ищите , если нашли 
// прервали цыкл.







// СДЕЛАЕМ ВМЕСТЕ ЗАДАНИЕ №:6 ИЗ ДОМАШКИ

// ЗАДАНИЕ №6

// Напиши скрипт который просит посетителя ввести число в prompt до тех пор, пока
// посетитель не нажмет Cancel и каждый раз добавляет введенное значение к общей
// сумме.

// 1 - При загрузке страницы пользователю предлагается в prompt ввести число.
// Ввод добавляется к значению переменной total.

// 2 - Операция ввода числа продолжается до тех пор, пока пользователь не нажьмет 
// кнопку Cancel в prompt.

// 3 - После того как пользователь прекратил ввод нажав кнопку Cancel, 
// поазать console.log со строкой 'Общая сумма чисел равна [сумма]'.

// Делать проверку того, что пользователь ввел именно число, а не произвольный
// набор символов, не нужно. Если хочешь, в случае некоректного ввода, показывай
// console.log с текстом 'Было введено не число, попробуйте ещё раз', при этом 
// результат prompt плюсовать к общей сумме не нужно, после чего снова пользователю 
// предлагается ввести число в prompt.



// Делаем АЛГОРИТМ выполнения (шаги выполнения)
// Нам неопходимо сделать ЦЫКЛ, который будет просить пользователя , тоесть нам надо
// сейчас составить АЛГОРИТМ - как мы должны решать задачи.


//  АЛГОРИТМ (шаги решения задачи)

// 1 - сосдать цикл который спрашывает пользователя ввести число.
// 2 - если ввели null остановить
// 3 - если ввели не null преобразовать в число и добавить в total
// 4 - после цикла вывести общую сумму введенных чисел

// В єтом примере показываем как делать бесконечный цикл - если условие while(true)
// ставим true то цикл бесконечный потому что условия всегда будут выполнятся.
// В таких случаях интресно использовать true потому что мы можем цикл прервать из нутри
// тоеть условие прерывания его нажатие Cancel

//  Это, что ниже, называется бесконечный цикл с прерыванием из его тела 
// по условию - это удобно



// do {

//     let input = prompt('Введи число');

//     if (input === null) {
//         break;
//     }

// } while(true)



//  А если условия while(input === null) ???  Тело цыкла - это блочная
// область видимости как у if и у for и т.д.
// Этого input вот здесь внизу while(input !== null)  не видно

//  Мы это может решить если вынести input в не этого цыкла и так его использовать


// let input;
// do {

//     input = prompt('Введи число');

// } while(input !== null)



// Делаем input = Number(input); преобразовываем строку в число
// Я сейчас это не запускаю потому будет сейчас БЕСКОНЕЧНЫЙ ЦЫКЛ
// ПОЧЕМУ???  
// Потому что, когда я нажымаю 1, 2, 3, 4, 5, - приводится к числу все хорошо, все работает
// Как только я нажымаю Cancel сюда возвращается null
// input = prompt('Введи число'); // null
// в числовом преобразовании null - это 0  (input = Number(input); // 0)
// и у нас цикл никогда не прервется

// что-бы остановить надо внутри цыкла делать дополнительную переменную, в которую
// сохранять результат преобразования в число и так далее... - ЭТО ОЧЕНЬ НЕУДОБНО


// let input;
// do {

//     input = prompt('Введи число'); // null   ЛУЧШЕ ТАК НЕ ДЕЛАТЬ

//     input = Number(input); // 0

// } while(input !== null)



// Мы разбираем как удобно выходить из цыкла

// В случае с break нам не нужно дополнительных переменных, нам не нужно внешних 
// переменных которые используются только в цыкле и все.



// ТОЕСТЬ ПРЕРЫВАТЬ ЦЫКЛ удобнее из его тела по моему условию

// Выполняем пункт 3 из нашего алгоритма: 3 - если ввели не null преобразовать в число и добавить в total
// Тут проверять если ввели не null не нужно, потому что у нас - если ввели null
// цикл прервался все и ничего ниже этого if не выполнится

// Если же это не null выполнется то что ниже
// и пишем 



// let total = 0;

// do {

//     let input = prompt('Введи число');

//     if (input === null) {
//         break;
//     }

//     input = Number(input);
//     total += input;

// } while (true)

// console.log(`Общая сумма ${total}`);



// В таком случае цикл do...while нам не нужен
// Пишем так
// Если в условии стоит тру while (true), то тело всегда выполняется хотя бы 1 раз



// let total = 0;

// while (true) {
//     let input = prompt('Введи число');

//     if (input === null) {
//         break;
//     }

//     input = Number(input);
//     total += input;
// }

// console.log(`Общая сумма ${total}`);




// Эсли в строку ввели не число а какие то буквы, то этот пункт input = Number(input);
// не сможет преобразовать строку в число, потому что ввелеи не число
// на выходе будет NaN

// Есть такая штука ПРОВЕРКА НА ЧИСЛО

// Если у нас Number(input); вернул нам NAN , то как проверить что 
// єто дейтвительно NaN??

// Есть такая функция специальная наз.  Number.isNaN

// Tсли пользователь ввел не число а буквы, добавляем переменную const notANumber = Number.isNaN(input);
// и условие if  с завершение даной итерации continue - продолжым цикл

// Разберем как это работает





//  Полная версия выполнения ЗАДАЧИ №6
// В работе такого никогда не встретиш, всегда будет строка

// let total = 0;

// while (true) {
//     let input = prompt('Введи число');

//     if (input === null) {
//         console.log(`Отменено пользователем!`);
//         break;
//     }

//     input = Number(input); // NaN (если пользователь ввел не число а буквы)

//     const notANumber = Number.isNaN(input);

//     if (notANumber) {
//         console.log(`Было введено не число, пропускаем текущую итерацию`);
//         continue;
//     }

//     total += input;
// }

// console.log(`Общая сумма ${total}`);



// Через for такие задачи не делаем
// for для того что-бы поработать с колекцией или с  числами, но не для того что-бы 
// получить что-то от пользователя n-нное количество раз, для этого for не используется
// у него совсем другое назначение, он буквально для того что-бы колекции перебирать
// инкрементить итератор и т.д.

// В повседневной работе используем for а для олимпиадных работ od...while
// В класических языках програмирования везде есть while do while, без этого 
// просто ни куда, это олд скул








// ЕКСПЕРИМЕНТ.  КАК РАБОТАТЬ С INPUT  УДОБНО  (в домашка этого нет но интересно)
// без проверок while, NaN и т.д.

// Мы с prompt работать не будем, мы будем работать с обычным интерфейсом с input

// В html добавляем 2 строки ввода input и одну кнопку

//  <label>
//     Число
//     <input type="number" name="number" />
// </label>
// <label>
//     Степень
//     <input type="number" name="power" />
// </label>
// <button>Возвести</button>


// Я показываю ОСНОВЫ как не заморачиваться и с Input получить значение

// Во-первых через java Script можно получить ссылку (тоеть достучатся к любому
// из этих элементов Input, кнопка, єти надписи Степень и т.д. что мы написали в html)
// Тоесть к любим этим элементам тегам (а в java Script они представлены как
// обьекты)  -  можно получить доступ.

// ОЧЕНЬ ПРОСТО

// document - глобальная переменная - это весь наш документ

// Используя такой метод - document.querySelector мы сюда можем передать наш
// селектор (''),  абсолютно любой CSS селектор.
// У нашем случае это селектор атрибута name - document.querySelector('input[name='number')
// вот эта штука как раз вернет ссылку на этот элемент

// Ref  - это референс ссылочка
// numberInputRef - так будет хорошо видно когда Вы получаете ссылку на элемент
// в html в документе вашем или это просто какая-то переменная со значением

// Любые input - это строка, и надо булет преобразовывать в число

//Смотрите я из Js могу получить на него ссылку и у этой красоты я могу взять
// значение, ввожу такое свойство value и получаю значение

// value - это значение того что мы вводим в поле ввода Число

// Это значение мы получем сразу при загрузке страницы



// const numberInputRef = document.querySelector('input[name="number"]');

// console.log(numberInputRef.value);



// Я бы хотела получить значение в какой то произвольный момент времени,
// например при нажатиии на кнопку (Возвести) .
// Я хочу отследить клик на эту кнопку и при клике на нее что-то сделать.

// 1- Надо получить ссылку на эту кнопку
// 2- вешаю слушателя на события, я говорю, я хочу при клике на эту кнопку сделать
// какой-то код
// Я получаю сслыку на эту кнопку

// Вызываю метод - addEventListener - добавить слушателя события
// в этот метод передаются 2 значения: 1- строка, с именем значения (в нашем 
// случае это ('click') и 2 - это стрелочная функция () => {} тоже самое что в 
// обычном JS написать function() {}

// И теперь при нажатии на эту кнопку (Возвести) будет выводится в консоль CLICK!


// const buttonRef = document.querySelector('button');
// buttonRef.addEventListener('click', function () {
//     console.log('CLICK!');
// })



// Такой же пример, только получаем текущее значение то что ввели в поле ввода input


// const numberInputRef = document.querySelector('input[name="number"]');
// const powerInputRef = document.querySelector('input[name="power"]');
// const buttonRef = document.querySelector('button');

// buttonRef.addEventListener('click', function () {
//     console.log('numberInputRef.value: ', numberInputRef.value);
//     console.log('powerInputRef.value: ', powerInputRef.value);

//     const number = Number(numberInputRef.value);
//     const power = Number(powerInputRef.value);

//     const result = Math.pow(number, power);
//     console.log(result);
// })
