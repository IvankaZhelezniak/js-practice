// Понятие СОБСТВЕННЫХ СВОЙСТВ ОБЬЕКТА

// Есть обьект objA у которых есть свойства q и z/
// И обьект objB прототипом которого мы указываем (objA).  Тоесть в objB будет свойства
// x и y,   а в его свойстве --proto-- будет ссылка на этот обьект objA.

// Вот эти вот свойства которые находятся непосредственно в objB  x и y называются -
// СОБСТВЕННЫМИ тоесть x и y это собственные свойства
// а вот эти вот q и z к которым мы можем получить доступ, тоесть B.z (по цепочке
// прототпов) будет найдено и значеныя выведятся - это называются УНАСЛЕДОВАНЫЕ свойства
// 


// const objA = {
//     q: 1,
//     z: 6,
// };

// const objB = Object.create(objA);

// objB.x = 1;
// objB.y = 2;

// console.log(objB);



// Помним у нас был такой цыкл назывался for...in длоя перебора обьектов, я говорил
// просто не юзайте его. Почему? Дело в том что по умолчанию цикл for...in перебирает не
// только СОБСТВЕННЫЕ но и УНАСЛЕДОВАНЫЕ свойства. Получается что он проходит по всей 
// цепочке прототитипов и выводит все (что нам практически и никогда не нужно).
// Это проблема, цыкл  for...in начинает копатся в прототипах выводить все все все
// свойства из цепочки не только Собственные.
// Поэтому мы его не используем.

// Для того что-бы проверить собственное свойство обьекта или нет у нас есть метод -
// hasOwnProperty (в переводе:  собственное имущество) - это предикатная функция 
// которая возвращает tru или false,  как includce

// const objA = {
//     q: 1,
//     z: 6,
// };

// const objB = Object.create(objA);

// objB.x = 1;
// objB.y = 2;
// console.log(objB.hasOwnProperty('x'));

// for (const key in objB) {
//     console.log(key);
// };






// ПОВТОРЯЕМ ФУНКЦИИ КОНСТРУКТОРы

// Мы попытаемся сделать систему классов для онлайн игры

// Будет базовый класс ГЕРОЙ, от него потом воин, маг ....

// Пишем базовую функцыю конструктор Hero