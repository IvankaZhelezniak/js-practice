// ОБЬЕКТЫ

// Обьект-  это структура данных которая позволяет нам хранить какой нибудь... 
// описывать какую-то сущность у которой много характеристик.
// Если массивы позволяют нам хранить колекцыю каких-то элементов то обьект
// позволяет описывать допустим продукт, пользователя, отель, карточку в треле, 
// єто что-то у чего есть много характеристик и надо их хранить в одном месте.
// Допустим у человека у пользователя емейл, пароль какой нибудь, план подписки и т.п.
// Не хранить же это в разных переменных - это хранится в одной переменной в 
// спецыальном типе данных  - ОБЬЕКТ

// Для того что-бы сделать создать Обьект пишем переменную какую-то например
// hotel и  ставим после = справа фигурные скобки {} - это называется 
// Литерал обьекта.
// Тоесть если у нас стоит if() {}  то эти скобки создают тело нашего if,
// тоесть это блок кода. 
// Тоже самое если у нас есть какая-то функция и мы пишем console.log({}) -
// это тоже называется литерал обьекта, это буквально вы в данном месте создаете
// обьект в данном случае передаете обьект в функции console.log

// Это просто структура данных


// const hotel = {};  /* литерал обьекта - справа от присваивания  */

// console.log({})  /*или при передаче в какую-то функцию - это литерал обьекта */

// if() {

// }   /*Это обычный блок кода, тоесть тело if или for или функции */




// ОБЬЕКТ состоит из набора свойств. Каждое свойство состоит из имени свойства 
// (ключ - имя свойства) и значения этого свойства
// Допустим у отеля будет имя (имя ствойства name) потом ставим двоеточие и 
// значение этого свойства (значение может быть что угодно: строка, буль, другой
// обьект, другой массив неважно)

// name: 'Sunset resort'   -  вот это называется СВОЙСТВО обьекта
// name:  - это ключ или имя свойства
// 'Sunset resort'   -   это значение свойства
// разделяются они двоеточием, потом через запятую можно давать и другие свойства
// 'Sunset resort', stars: 5, capacity: 200

// Обьект - это струтура данных котороя позволяет хранить в одной переменной
// описательные характеристики одной сущности, в даном случае это отель наш
// и мы его запихнули в один обьект

// Вертикально, читается приятнее, потому что каждое свойство на своей строке стоит
// Свойства разделяем запятой



// const hotel = {
// name: 'Sunset resort', 
// stars: 5,
// capacity: 200,
// '1c-apa city': 200,     /*такого не бывает но можно*/
// };



// Ключи name, stars, capacity - всегда будут строки. Тоесть ключ, имя свойства 
// это всегда строка.
// Имя ключа это имя характеристики, тоесть что вы сейчас будет здесь хранить
// (например isOnline: true  или false),
// должно быть без пробелов, без тире, начинатся должно на букву ил на _ или на $
// на цыфру не может начинатся
// Если надо явно что-бы в имени были пробели или тире тогда делаем строку и пишем
// туда все что хочем с тире и пробелами '1c-apa city' - такого не бывает но можно




// ДОСТУП К СВОЙСТВАМ в обьекте

// Давайте выведем в консоль наш отель
// Как достучатся к свойствам обьекта, очень просто - hotel.name (готель точка и 
// имя свойства ключ, записываем в консоль лог)
// Когда интерпретатор видет такое выражение console.log(hotel.name); он идет в 
// обьект hotel ищет там свойство с именем name и возвращает на это место его значение.
// Я вижу в консоль Sunset resort.
// Если поставим stars  - console.log(hotel.stars); он вернет 5.

// Вот так идет поиск, это первый вариант и такой вариант используется в 99% случаев

// Если я обращусь к свойству которого не существует в обьекте, допустим какой-то
// guests  -  console.log(hotel.guests); свойство с таким именем ключом просто 
// не существует, я получу undefined


// const hotel = {
// name: 'Sunset resort', 
// stars: 5,
// capacity: 200,
// };

// console.log(hotel);
// console.log(hotel.stars);
// console.log(hotel.guests);  /*свойства с таким именем не существует - undefined */




// ВТОРОЙ СПОСОБ достучатся к свойтсвам
// иногда бывает когда необходимо, когда у нас ключ сложный (когда у нас не просто
// какое-то имя как будто переменной), когда наш ключ содержит пробелы, тире или
// когда ключ хранится в переменной -  
// мы можем к тому же самому свойству name достучатся вот так вот, вы пишете 
// hotel кватдратные скобки и в нее строку которая является ключом - 
// console.log(hotel[`name`]); ключ это всегда строрка, тесть когда мы здесь
// написали name, насамом деле под капотом приводится вот к такому 'name' строка
// const hotel = {
// name: 'Sunset resort',  к такому приводится 'name': 'Sunset resort' - это строка
// 
// Поэтому когда мы пытаемся вот в этих вот квадратных скобках достучатся к имени
// свойства
// если просто потавим console.log(hotel[name]); hotel[name] - это имя идентификатора
// это имя переменной, интерпретатор будет выше в коде где-то искать буквально имя
// такой переменной, естественно у нас такой переменной просто не существует 
// сейчас будет undefined.
// Поєтому мі ставим строку ['name'] - console.log(hotel['name']);  и на это место
// возвращается значение этого свойства с таким именем.

// Тоесть можно и так console.log(hotel.name); и так console.log(hotel['name']);
// Практически всегнда будет вот такой доступ к свойствам console.log(hotel.name);
// А это будет console.log(hotel['name']);  в том случае когда или какое-то сложное
// имя у свойства или когда это значение ['name'] лежит в переменной


// const hotel = {
// name: 'Sunset resort', 
// stars: 5,
// capacity: 200,
// };

// console.log(hotel);
// console.log(hotel.name);
// console.log(hotel['name']);



// или когда это значение ['name'] лежит в переменной.
// Смотрите, делаем такое const key = 'stars';
// у меня сейчас в переменной key лежит строка 'stars',  тоесть буквально имя 
// свойства stars, в которое мы хотим в этом обьекте hotel достучатся, лежит внутри
// этой переменной key  и если я попробую сделать что-то вроде бы вот такого
// console.log(hotel.key); - вот это hotel.key то что вы здесь пишите точка и что-то
// типа key это не значит что это имя переменной после точки.
// После точки оно буквально берет вот это .key как строку и такой ключ ищет внутри
// этого обьекта hotel. Тут в hotel ключа с именем key просто не существует, будет
// undefined. Тоесть если я тут в hotel добавлю вот такое key: 100 оно будет 
// буквально искать такую штуку и покажет 100.
// Тосеть то что после точки console.log(hotel.key); это не имя переменной это
// буквально имя свойства и  оно будет его пытатся найти в обьекте (естественно у
// обьекта такого свойства нет).

// Так вот когда ИМЯ СВОЙСТВА ХРАНИТСЯ В ПЕРЕМЕННОЙ то тогда мы используем\
// квадратные скобки и передаем сюда имя переменной console.log(hotel[key]);
// На это место [key] интерпретатор подставляет значение тоесть вот эту 
// строку 'stars' и получается вот так console.log(hotel['stars']);
// В таких случаях мы используем квадратные скобки
// ложных ключей очень мало, чаще всего имя свойства хранится в переменной, тогда 
// мы используем квадратные скобки, чаще всего просто через точку console.log(hotel.name);


// const hotel = {
// name: 'Sunset resort', 
// stars: 5,
// capacity: 200,
// };

// console.log(hotel);
// console.log(hotel.stars);

// const key = 'stars';

// console.log(hotel[key]);

// hotel.stars = 3;
// hotel.guests = [];
// console.log(hotel);



// ЕСЛИ Я ХОЧУ ПЕРЕЗАПИСАТЬ КАКОЕ-ТО ЗНАЧЕНИЕ
// У меня был 5-ти звездночный готель, он теперь должен стать 3-х звёздочным
// мы просто пишем hotel.stars = 3;  и выводим console.log(hotel);
// Тоесть вот эта ссылка на обьект hotel (обьект это тоже ссылочный тип, как и 
// массив он сложный тип) вот это внутри него свойство .stars, я к нему постучался
// и говорю - запиши туда это значение = 3.
// Все по ссылке в это его свойство записалось другое значение

// Если же такого свойства раньше не было, ну допустим hotel.guests = []; равно
// пустой массив то мне просто в этом обьекте сделается свойство guests в котором 
// поместится пустой массив guests: [], если его там  не было оно туда добавится
// это очень удобно
// если было оно перезапишется на то значение которое вы указали






// ССЫЛОЧНЫЕ ТИПЫ

// Обьект как и массив это ссылочный тип, тоесть копируется по ссылке.
// Если в a лежит обьект (const a = { x: 1, y: 2 })  в b мы присваиваем a
// (const b = a;)  тов  b === а  когда? тогда когда это одна и 
// та же ссылка на один и тотже обьект, тогда это будет true


// const a = { x: 1, y: 2 }
// const b = a;

// console.log(b === a);



// Секрет. На самом деле функцый и массивов нету в js, в js есть только обьекты.
// Потому что и массивы и функции - это обьекты  только очень хитрие.
// Если кто-то изучал класические языки програмирования то есть массив в них.
// А в js массив это отдельный случай обьекта
// Смотрите есть массив с индексами, а теперь делаем вот так вот arr.hello = ':)';
// console.log(arr);
// И у нас неожиданно в массиве появляется индекс hello со значением смайлика
// Массив это просто такой подвид обьекта спецыальный

// То же самое с функцыей, если я делаю какую-то функцию const fn = function () {}
// я на функцию записал свойство hello  -  fn.hello = 'xD'; и присвоил смайлик
// а потом я к этой функции обратился к её свойству и получил этот смайлик обратно
// в консоль
// тоесть массивы и функции насамом деле это подвид обьекта. (надо для собеседование)
// могут спросить а что такое массив а что такое функция, массив это тот же самый
// обьект, только у массива ключи назначаются в порядке от 0 до бесконечности под капотом
// а в обьекте мы сами их устанавливаем


// const arr = ['a', 'b', 'c'];
// console.log(arr);

// arr.hello = ':)';
// console.log(arr);

// const fn = function () {};
// fn.hello = 'xD';
// console.log(fn.hello);





// МЕТОДЫ ОБЬЕКТА

// Обьект это не просто структура данных которая позволяет хранить какой-то набор 
// характеристик которые описывают сущность, они так же помогают сразу хранить 
// методы для работы с этими данными тоесть обьект хранит и данные и еще и метод 
// для работы с этими данными

// Допустим есть у нас отель и надо изменить имя его, канешно можем написать функцыю
// const updateHotelName = function (hotel, newName) {
// updateHotelName  - обновить название отеля

// Помним что обьект это ссылочный тип, потом вызываем его ниже, передавать ссылку 
// на наш отель и потом говорить какое-то имя там например 'Lagoon'
// updateHotelName(hotel, 'Lagoon');
// тогда вгутри функиции мы говрим hotel. у него есть свойство name = newName
// и если мы потом посмотрим на наш отель console.log(hotel); то мы видим что его
// имя теперь лагуна все хорошо, НО сейчас эта функцыя в нашем коде она никак не 
// связана напрямую с этим обьектом, она принимает просто этот обьект новое имя 
// и что-то в нем меняет


// const hotel = {
// name: 'Sunset resort', 
// stars: 5,
// capacity: 200,
// };

// const updateHotelName = function (hotel, newName) {
//     hotel.name = newName;
// }

// updateHotelName(hotel, 'Lagoon');
// console.log(hotel);




// Доступ к объекту через this

// Можно в обьекте хранить сразу МЕТОДЫ, тоесть те же самые функции которые 
// будут изменять значение его свойств 
// Мы просто в обьекте hotel можем хранить updateName это просто свойство в котором лежит
// функция которая будет принимать newName и делать то же самое практически
// updateName: function (newName) {
// тоесть вместо того что-бы хранить какую-то внешнюю функцию которая работает 
// с этим обьектом Вы можете хранить эту функцию как часть обьекта hotel что-бы 
// она работала с его же данными и тогда все это будет вместе связано хорошо
// 
// КАК обратится к обьекту внутри его метода, тоесть я хочу получить доступ к этому 
// name.  Я не пишу так hotel.name нивкоем случае никогда так неделайте 
// ЗАПОМНИТЬ: для того что-бы обратится к какому-то обьекту внутри его метода 
// функции мы используем ЗАРЕЗЕРВИРОВАННОЕ КЛЮЧЕВОЕ СЛОВО this - это контекс, с ним
// мы будем знакомится потом чуть позже, мы будем разбирать его детально, тем не 
// менее запомните: Если вы хотите обратится к свойству обьекта внутри метода 
// обьекта пишем вот так  this.name -  this это ссылка на сам обьект hotel  
// this.name = newName; - это пишем внутри метода функции
// смотрите выводим console.log(hotel);   и смотрим наш отель хранит updateName 
// как функцию которая принимает новое имя и теперь мы можем сделать 
// hotel.updateName('Lagoon');  и сюда передать новое имя 'Lagoon'
// потом смотрим на этот отель  console.log(hotel); и теперь там лежит лагуна

// ЕСЛИ в методе обьекта мы хочем достучатся к его свойству допустим любому из
// свойств обьекта, изменить его посмотреть на него неважно, мы вместо имени обьекта
// тоесть вместо имени той переменоой в которой лежит этот обьект, мы обращаемся 
// к ключевому слову this - это ссылка на этот вот обьект и уже у него есть эти 
// свойства name, stars, capacity...



// const hotel = {
// name: 'Sunset resort', 
// stars: 5,
//     capacity: 200,
//     updateName: function (newName) {
//         console.log(this.name);

//         this.name = newName;
// },
// };
// console.log(hotel);

// hotel.updateName('Lagoon');
// console.log(hotel);



// Это что мы записали вверху это синтаксис довольно старый, я просто вам показываю
// что метод обьекта это просто свойство значением которого является функция.

// Сейчас есть новый синтаксис так и называется МЕТОД ОБЬЕКТА СИНТАКСИС
// Это когда вот так записывается вот так просто без двоеточий и слова function

// ПИСАТЬ ИМЕННО ТАК нам нужен метод, мы пишем имя метода updateName и открываем
// скобки (newName) потом тело метода {} - это синтаксис МЕТОДА ОБЬЕКТА современная версия

// const hotel = {
// name: 'Sunset resort', 
// stars: 5,
//     capacity: 200,
//     updateName(newName) {
//         console.log(this.name);

//         this.name = newName;
// },
// };
// console.log(hotel);

// hotel.updateName('Lagoon');
// console.log(hotel);



// ДЕЛАЕМ ЕЩЁ один какой-то метод  (первод someMethod - какой-то метод)
// someMethod() {
// в нем есть привет из какого то метода console.log('Hello from someMethod');
// я его могу вызвать снизу hotel.someMethod(); тоеть метод это функция я её вызиваю
// законсолилось все хорошо.

// Что если нам нужно в одном методе обьекта вызвать другой метод обьекта, проблем
// вообще никаких - в любом месте в любом другом методе ты можеш вызвать 
// пишем this.someMethod();
// В одном методе можно вызивать другие методы обьекта обращаясь через this.имя


// const hotel = {
// name: 'Sunset resort', 
// stars: 5,
//     capacity: 200,
//     updateName(newName) {
//         console.log(this.name);

//         this.someMethod();
//         this.name = newName;
//     },
//     someMethod() {
//         console.log('Hello from someMethod');
//     }
// };

// hotel.updateName('Lagoon');
// hotel.someMethod();




// Как достучатся к глубоким свойствам? Просто cтроим цепочку 
// console.log(objA.objB.y);

// const objA = {
//     x: 1,
//     objB: {
//         y: 5,
//     },
// };

// console.log(objA.objB.y);





// ПЕРЕБОР обьектов

// Когда мы перебирали массивы у нас есть такой прекрасный цикл как for или for...of
// с обьектами они не работают, обьекты это неитерируемая сущность в плане вот этих
// вот for и for...of  , они там не работаю.
// Для того что-бы они работали там должны быть индексы и другая штука под капотом
// в общем ЧТО-БЫ ПЕРЕБРАТЬ ОБЬЕКТ есть олдскульная конструкция for...in
// работает это так:  Вы пишите for потом ключ в обьекте  for (key in object)
// вот этот оператор in проверяет есть ли ключ в обьекте

// Смотрите у нас есть обьект feedback (в переводе feedback- обратная связь) - это 
// допустим пользователь оставляет отзыв о моей компании, это собирается в обьект
// где количество хороших отзывов good: 5;   нейтральных и плохихи отзывов.
// Я могу написать что имя ключа in feedback, вот этот вот оператор in 
// возвращает true если это свойство с таким ключом в обьекте есть.
// Если свойства с таким ключом 'qweqwe' то он вернет false/
// Практически это никому не надо но тем не менее это существует

// const feedback = {
//     good: 5,
//     neutral: 10,
//     bad: 3,
// };
// console.log('good' in feedback);


// Так вот цикл for...in,   for(const key) ставим конст key ключ, опять же єто просто
// имя локальной переменной для этого цикла вот здесь будет использоваться вот это 
// имя ключа console.log(key), поэтому называют эту переменную key ключ
// пишем for(const key in  feedback) {console.log(key)}  и видим что я получаю?
// Я получаю вот в эту переменную key поочерёдна вот эти вот ключи good, neutral,
// bad на каждую итерацыю, тоесть оно перебирает этот обьект и на каждой итерации
// получаю вот этот ключ ключ ключ
// Для того что-бы теперь достучатся к значению ,  у меня есть переменная key в 
// которой лежит вот эта строка good,  если первую делаю ошибку 
//  console.log(feedback.key)  - почему так работать не будет? Потому что оно буквально
// пойдет в обьект feedback и будет там искать свойство с именем key , а такого 
// ключа имени свойства нет, будет undefined/
// Если свойство лежит внутри переменной тогда я ставлю квадратные скобки и туда 
// передаю эту переменную console.log(feedback[key]);  тогда в это место [key]
// подставляется её значение тоесть строка  good или neutral или bad.
// И это тоже самое что на первой итерации будет вот это вот -
// console.log(feedback['good']);   на второй итерации будет вот это - 
// console.log(feedback['neutral']); и на ретьей итерации будет вот так вот - 
// console.log(feedback['bad']);

// И тогда мы получаем ключ на каждой итерации и потом сами ручками получаем значение
// этого ключа, это 5, 10 и 3.

// Допустим если там надо собрать total (общее)  totalFeedback (общая обратная связь)
// мы внутри for можем сделать totalFeedback += feedback[key];  и выводим в консоль
// console.log('Total: ', totalFeedback);   я получу общую сумму значений обьекта,
// общее количество отзывов 18
// Вот так вот перебираются обьекты
// ЭТО СТАРЫЙ МЕТОД ОЛДСКУД,  мы должны про него знать, мы может где-то его применим
// но на самом деле мы for...in юзать не будем  +  у него есть такая очень нехорошая
// особенность про которую я раскажу во время прототипного наследования,
// потому что этот цикл по умолчанию он перебирает ключи ещё и у предков его, ну 
// опять же сейчас это нам не будет понятно поэтому просто скажу:  знайте что он есть
// что он перебирает ключи, мы его юзать не будем пока что и вообще наверное, 
// когда будет прототипное наследование я детально раскажу почему вы его не 
// использоваете и почему он перебирает ключи у предков, есть такая штука прототипное
// наследование цепочка.


// const feedback = {
//     good: 5,
//     neutral: 10,
//     bad: 3,
// };

// let totalFeedback = 0;

// for (const key in feedback) {
//     console.log(key);
//     console.log(feedback[key]);

//     totalFeedback += feedback[key];
// }

// console.log('Total: ', totalFeedback);




// ЧЕМ ПЕРЕБИРАЮТ ОБЬЕКТЫ СЕЙЧАС
// Вообще работать с переборам обьектов неудобно, потому что неважно в каком порядке 
// Вы написали ключи, порядок перебора их негарантируется.
// Потому что если массив это набор индексируемых значений, тоесть они идут по 
// возрастанию, то ключи в обьекте браузер может менят как хочет, тоесть это такой
// мешок с канфетами который можно трусить и они в произвольном порядке будут там
// становится.


// НА СЕГОДНЯШНИЙ ДЕНЬ есть методы прямо контсрукторы
// Есть такой контструктор называется Object, тоесть у каждого типа вообще есть Object
// есть String и Array - это родительские конструкторы вот этих вот типов Number
// в JS, это базовое, это функции на сомом деле, это то из чего создаются вообще
// эти типы даных ваши, вот вы говорите литерал обьекта а на самом деле под катотом 
// происходит вызов контсруктора new Array() и так далее. создается из него.

// У вот этих вот конструкторов есть статические методы, но это буквально МЕТОДЫ
// САМИХ КОНСТРУКТОРОВ и в современном js есть 



// МЕТОД  Object.keys(feedback)    
// 
// и сюда у скобки () мы передаем наш обьект  вот так Object.keys(feedback)   
// На место вот этого вызова мы получим все ключи этого обьекта feedback в виде
// массива
// МЫ получим ключи в виде массива, он буквально проходится по этому обьекту,
// вытягивает у него все его ключи и запихывает в эту переменную keys массив с этими
// ключами ["good", "neutral", "bad"]


// const feedback = {
//     good: 5,
//     neutral: 10,
//     bad: 3,
// };

// const keys = Object.keys(feedback);  
// console.log(keys);




// ПРИМЕР задача:  посчитать сколько свойств есть в обьекте.
// Мы можем взять Object.keys пройтись на этом feedback. Это keys массив 
// и смотрим длинну массива length   console.log(keys.length);
// Вот столько свойств в обьекте feedback - 3

// Мы просто получаем массив ключей и смотрим его длинну

// const feedback = {
//     good: 5,
//     neutral: 10,
//     bad: 3,
// };

// const keys = Object.keys(feedback);  
// console.log(keys.length);



// ПРИМЕР ещё лучше 
// Вот мы делаем keys это массив, теперь мы делаем обычный перебор массива циклом for
// for (const key of keys) {console.log(key);  console.log(feedback[key]);}
// вот мы получаем доступ к 5, 10, 3
// Мы сначала переводим в массив ключей, перебираем массив ключей (тоесть из обьекта
// делаем массив его ключей) и на каждой итерации мы получаем доступ к их значениям

// const feedback = {
//     good: 5,
//     neutral: 10,
//     bad: 3,
// };

// const keys = Object.keys(feedback);

// for (const key of keys) {
//     console.log(key);
//     console.log(feedback[key]);
// }



// ТО же самое можем сделать с total (общее) let totalFeedback = 0;
// И получаем тотал также 18

// Работать с массивом приятнее чем с обьектом, перебирать массив ключей его

// const feedback = {
//     good: 5,
//     neutral: 10,
//     bad: 3,
// };

// const keys = Object.keys(feedback);
// let totalFeedback = 0;

// for (const key of keys) {
//     console.log(key);
//     console.log(feedback[key]);

//     totalFeedback += feedback[key];
// }
// console.log('Total: ', totalFeedback);




// МЕТОД Object.values()  -  если нам надо что-то сделать со всеми значениями обьекта
// на выходе console.log(values); я получаю массив всех значений свойства обьекта

/* 
const feedback = {
    good: 5,
    neutral: 10,
    bad: 3,
};

const values = Object.values(feedback);
console.log(values);
 */



// ПРИМЕР. Задача. Приходит обьект со всеми зарплатами, вам надо посчитать общую 
// зарплату у людей, тебе не надо for...in перебираить что-то там думать ты просто
// взял Object.values и тебе вернулся массив всех зарплат тоесть всех значений 
// свойств, тоесть массив зарплат
// и теперь просто мы перебираем его в цикле 
// и считаем общее количество

// const feedback = {
//     good: 5,
//     neutral: 10,
//     bad: 3,
// };

// const values = Object.values(feedback);
// console.log(values);

// let totalFeedback = 0;

// for (const value of values) {
//     console.log(value);
//     totalFeedback += value;
// }

// console.log('Total: ', totalFeedback);




// Метод  Object.entries  -  это записи (он не очень часто юзается )
// console.log(Object.entries(feedback));  - мы получаем массив   массивов.
// Мы получаем массив каждый элемент которово является тоже массивом где  1 элемент
// это имя ключа , 2-рой элемент это значение.

// const feedback = {
//     good: 5,
//     neutral: 10,
//     bad: 3,
// };

// console.log(Object.entries(feedback));



// А как метод будет отображатся при entries?  
// Ни на одном обьекте на котором есть методы не вызывается ни Object.keys ни
// Object.values ни Object.entries.  
// Object.keys,  Object.values, Object.entries  нужны для обьектов данных.
// Смотрите когда мы писали этот отель const feedback = { good: 5, neutral: 10,
// bad: 3, };  -  то это просто обьект данных, тут нет методов для работы с этими 
// данными. Это как маленькая база данных на них применяют keys, values, entries/
// Но когда мы говорим про обьекты в которых есть методы то на них не применяют 
// keys, values, entries потому что нет таких задач, тоесть переби рать свойства 
// которые являются функцией безсмысленно. Ну их просто нету это не нужно





// Познакомились с основами теперь давайте поработаем с ними

// Естественно в голом виде обьекты не полезны, большинство вашего кода, подавляющее
// большенство мы будем работать не с обьектом самим по себе а с массивом обьекта
// тоесть когда мы видим на розетке, зашли продукты получать там эти карточки товаров
// это массив обьектов пришол откуда-то.
// Практически все что Вы видите в интерфейсе где вы видите какую-то колекцыю
// это под капотом был массив обьектов а потом из него создали интерфейс

// Помните мы прошлый  раз использовази у нас были друзья просто как массив строк
// и мы использовали includes для того что-бы найти имя в массиве. На сомом деле это
// будет массив вот таких вот обьектов, тоесть каждым элементом массива будет обьект
// выводим вот console.log(friends); и будет массив где каждым элементом будет
// обьект, и потом у каждого обьекта будет имя друга и онлайн он или офлайн.


// const friends = [
//     { name: 'Mango', online: false },
//     { name: 'Kiwi', online: true },
//     { name: 'Poly', online: true },
//     { name: 'Ajax', online: false },
// ];

// console.log(friends);


// Когда мы работаем с массивом обьектов, не только тс массивом обьектов, удобно 
// использовать не console.log а console.table он сделает такую красоту. Он укажет
// индекс и потом будут свойства вашших обьектов стоять как в таблице

// const friends = [
//     { name: 'Mango', online: false },
//     { name: 'Kiwi', online: true },
//     { name: 'Poly', online: true },
//     { name: 'Ajax', online: false },
// ];

// console.table(friends);



// Если я обращусь например к friends[0] нулевому, то это будет первый обьект
// { name: 'Mango', online: false }.
// Каждый элемент массива это есть обьект, не какоя-то строка или число а именно
// обьект - сложный тип данных

// const friends = [
//     { name: 'Mango', online: false },
//     { name: 'Kiwi', online: true },
//     { name: 'Poly', online: true },
//     { name: 'Ajax', online: false },
// ];

// console.table(friends);
// console.log(friends[0]);



// ТЕПЕРЬ будем перебирать это дело
// Напоминаю що с includes я не могу найти обьект в массиве friends.includes(), 
// includes работает только на простой тип на строку на число и т.д. обьекты так 
// найти нельзя, прийдется массив перебирать.
// 
// Тоесть если я хочу написать какую-то штуку каторая ищет меня по имени, допустим
// вот так const nameToFind = 'Poly';  то мне необходимо будет сделать следующее,
// нужно перебрать этот массив в цикле. Это обычный массив друг из друзей 
// for (const friend of friends) {
// На каждой итерации мы получаем доступ к отдельному обьекту, тоесть к нулевому 
// элементу массива, первому, второму и третьему. Тоесть friend это ссылка на вот
// такой обьект { name: 'Mango', online: false },  я в нем могу взять допустим .name
// у каждого из них console.log(friend.name); и я получу имена из этих обьектов на 
// каждой итерации, если надо онлайн посмтреть пишем .online  console.log(friend.online);
// я вижу и могу получить доступ к свойству онлайн на каждой итерации у каждого из 
// этих обьектов

// Теперь, когда мы работаем с массивом обьектов 90% кода это просто циклы + if,
// другово просто нету. Вы перебираете этот массив обьектов и вы на каждой итерации
// что-то проверяете, допустим у нас есть имя друга которое нужно найти
// const nameToFind = 'Poly';

// Смотрим на каждой итеоации есть доступ к friend.name, мы просто проверяем
// if (friend.name === 'Poly') { console.log('Нашли Poly!!!') break;}  ну и прервем цикл
// на всякий случай break;
// Все нашли поли.
// Почему мы видим только 3 итерации в консоль? Потому что 1-вая итерация с нулевым
// элементом это if не выполнился friend.name не был Poly,  на второй итерации тоже
// самое и только в 3-тьей итерации мы увидили что оно равно, нашли поли и break; 
// прервали цикл.

// НАШЛИ ДРУГА ПО ИМЕНИ циклом

// const friends = [
//     { name: 'Mango', online: false },
//     { name: 'Kiwi', online: true },
//     { name: 'Poly', online: true },
//     { name: 'Ajax', online: false },
// ];

// console.table(friends);

// for (const friend of friends) {
//     console.log(friend);

//     if (friend.name === 'Poly') {
//         console.log('Нашли Poly!!!');
//         break;
//     }

// }


// ЗАПОМНИТЬ:  Работа с массивом обьектом это просто переборы какие-то постоянные
// + сравнение значений if (friend.name === 'Poly')

// Тоесть если я пишу функцию найти друга по имени(findFriendByName - найти друга по имени)
// я тут передаю всех друзей массива обьекта и он будет записыватся в эту переменную
// allFriends      const findFriendByName = function (allFriends, name) {
// и name
// будем вызивать так функцию console.log(findFriendByName(friends, 'Poly')); и
// должно возвращать нам true или false неважно что-то возвращать должно вот эта 
// функция findFriendByName. Соответственно мы сюда friends будем передавать всех
// наших друзей в массив обьекта и он будет записіваться в эту переменную allFriends.
// Тогда мы берем этот for (const friend of allFriends) { - друг из всех друзей
// и получаем 2 перебора потому 2 вызова функции
// и потом тоже самое проверяем через if, что если friend.name
// потому что мы знаем что в этом массиве allFriends в каждом обьекте, которым
// является щас переменная friend есть свойство name. Тоесть это не магия там не надо
// додумыватся что-то там
// сравниваем if(friend.name === name)  и что-то возвращаем return 'Нашли!!!'

// Вы видите что я здесь делаю return, тоесть если я в этом цикле нашол друга, 
// то я просто return тут какую-то строку типа 'Нашли!!!'  и 
// тогда эта функция виполнения  полностью прекращается.
// А если этот for прошол и ни разу этот if не выполнился я ему могу просто вернуть
// в конце функции return 'Не нашли :('

// Видите в первом случае мы нашли друга а во втором случае мы друга не нашли

// Так работает практически весь код с массивами обьектов
// просто какой то цикл по массиву, потом на каждой итерации какое-то свойство у 
// обьекта сравнивает с тем что передали и что-то делаете по результату.

// Пербрали, на каждой итерации сравнили, если совпало что-то делаем не совпало что-то делаем

// НАШЛИ ДРУГА ПО ИМЕНИ через функцию

// const friends = [
//     { name: 'Mango', online: false },
//     { name: 'Kiwi', online: true },
//     { name: 'Poly', online: true },
//     { name: 'Ajax', online: false },
// ];

// const findFriendByName = function (allFriends, name) {
//     for (const friend of allFriends) {
//         console.log(friend);

//         if (friend.name === name) {
//             return 'Нашли!!!'
//         }
//     }
//     return 'Не нашли :('
// }

// console.log(findFriendByName(friends, 'Poly'));
// console.log(findFriendByName(friends, 'Chelsy'));




// ПОЛУЧАЕМ ИМЕНА ВСЕХ ДРУЗЕЙ
// А теперь необходимо получить имена всех друзей из массива обьектов
// Пишем функцию  getAllNames (получить все имена)
// пишем function что-бы мы привикали что эти все операции будут в результате 
// методов или еще где-то просто функции
// Вот мы передали всех друзей allFriend  (const getAllNames = function (allFriend) {)
// и теперь нужно получить все имена этих друзей, опять же все имена?
// скорее всего эта фекция должна возвращать какой-то массив тоесть на выходе она
// возвращает какой-то масивчик return []
// Этот тоже массив allFriend перебираем for (const friend of allFriend) {
// тоже самое, просто получаю доступ к каждому обьекту на каждой итерации
// и вот на каждой итерации есть у меня доступ к этому свойству name типа
// friend.name и там будет это имя валятся. Поэтому я могу сделать какойто пустой
// массив типа   const name = []; и на каждой итерации сделать следующее
// names.push(friend.name);  и на выходе получу массив имен

// const friends = [
//     { name: 'Mango', online: false },
//     { name: 'Kiwi', online: true },
//     { name: 'Poly', online: true },
//     { name: 'Ajax', online: false },
// ];

// const getAllNames = function (allFriend) {
//     const names = [];

//     for (const friend of allFriend) {
//         names.push(friend.name);
//     }
//     return names;
// }




// ПОЛУЧАЕМ ИМЕНА ТОЛЬКО ДРУЗЕЙ КОТОРЫЕ ОНЛАЙН

// Ещё раз делаем буквально тоже самое просто переберем массив, просто что-бы
// больше одно и то же делать и запомнить
// getOnlineFriends  - получить друзей в сети
// делаем опят же пустой массив const names = [];  сделаи и будем его возвращать
// return names;  и теперь в этот массив const names = []; будем набивать именно
// тех друзей которые онлайн. Опять же что сделаем? У нас будут вызовы такие вот -
// мы берем наших друзей console.log(getOnlineFriends(friends));  массив friends
// и у каждого из этих массивов есть свойство онлайн.
// Вот мы как раз его и можем проверить тут или true или false, онлайн или не онлайн
// Делаем перебор массива обьектов for (const friend of friends) {
// В параметрах allFriends лежит ссылка на эти friends
// и теперь говорим если в этого друга в свойстве онлайн лежит true мы можем пушить
// у names свое имя если нет ничего не делаем

// const friends = [
//     { name: 'Mango', online: false },
//     { name: 'Kiwi', online: true },
//     { name: 'Poly', online: true },
//     { name: 'Ajax', online: false },
// ];

// const getOnlineFriends = function (allFriends) {
//     const names = [];

//     for (const friend of friends) {
//         console.log(friend);

//         if (friend.online) {
//             names.push(friend.name);
//         }
//     }

//     return names;
// }

// console.log(getOnlineFriends(friends));

// Заметили, одно и то же самое, перебери сравни сделай, другово просто нет, это
// все задачи на массив обьектов, они стандартные





// ПОЛУЧАЕМ ИМЕНА ТОЛЬКО ДРУЗЕЙ КОТОРЫЕ НЕ ОНЛАЙН

// const friends = [
//     { name: 'Mango', online: false },
//     { name: 'Kiwi', online: true },
//     { name: 'Poly', online: true },
//     { name: 'Ajax', online: false },
// ];

// const getOfflineFriends = function (allFriends) {
//     const names = [];

//     for (const friend of friends) {
//         console.log(friend);

//         if (!friend.online) {
//             names.push(friend.name);
//         }
//     }

//     return names;
// }

// console.log(getOfflineFriends(friends));





// РАБОТАЕМ С КОЛЛЕКЦИЕЙ ТОВАРОВ В КОРЗИНЕ

// Мы работаме с коллекцией товаров в корзине, тоесть ДЕЛАЕМ КОРЗИНУ ТОВАРОВ
// 
// Что такое корзина товаров? - это обьект в котором хранится массив элементов тоесть
// массив обьектов товаров которые лежат в этой корзине + методы для того что-бы что-то
// добавить в корзину удалить с корзины, очистить корзину. Вот когда в интерфейсе, 
// допустим ты заходиш на магазин и нажымаеш добавить в корзину. Корзина, на самом
// деле это вот такой обьект const cart = {items: [],} и пусть у него есть свойство items в
// котором лежит массив []
// cart - тележка, корзина
// items  -  предметы
// Тоесть когда ты нажымаеш добавить в корзину, вот в этот массив items: [], добавляется
// какой-то обьект, у этого обьекта есть какие-то свойства которые в этом магазине
// используются.  И потом есть методы вот етой же корзины cart для работы с этим массивом
// items: [],.  Все что мы видим на екране это все данные, которые где-то под капотом лежат
// и из них уже это все нарисовалось для тебя.

// const cart = {
//     items: [],
// }




// Будем работать с обьектами у которых будут свойства имя и цена у каждого
// Нам необходимо сделать написать методы:

// 1-вый метод это getItems() что-бы можно было из этой корзины получить все её элементы,
// тоесть все обьекты которые в ней лежат
// 1-вый метод getItems() будет просто возвращать ссылку на вот это свойство items: [],
// пишем  return this.items;  Все, это нам просто для того что-бы во внешнем коде получить
// доступ.  Я могу просто написать карточка items (cart.items) но это не будет очень
// хорошо, необходимо что-бы у вашей сущности (например то что мы создаем сейчас называется
// интрефейс cart = {....,  не всмысле что кнопочки и какие то менюшки, интерфейс - 
// это у каких-то данных есть набор методов которые открываются разработчику что-бы 
// использовать, и вот это cart = {
// items: [],
// getItems() {
//     return this.items;
// })              называется по хорошему интерфейс в этой корзине набор методов для
// тебя есть. Так вот мы создаем интерфейс или API
// 
// ИСПОЛЬЗУЕМ МЕТОДЫ ДЛЯ ДОСТУПА ДЛЯ ОБНОВЛЕНИЯ

// Получили наш getItems (console.log(cart.getItems());) , что он будет делать этот getItems
// сразу ставим console.table что-бы выводило в табличку, так удобнее (сейчас там пустой 
// массив просто лежит)

// 2-рой метод add(product)  -  добавляем, получаем весь продукт
// ТЕПЕРЬ будем добавлять продукт, тоесть  у нас будет метод add который будет получать
// целиком product тоесть весь продукт. И пока что мы не будем проверять есть ли он в корзине
// или нет его в корзине, пока что просто будем добалять. Как это делать? У нас есть вот
// этот массив items: [], мы будем в него просто пушить (push). Сначала вызовем что-бы 
// посмотреть, пишем card.add() и сюда надо передать вот этот вот обьект, тоесть этот add 
// это когда в интерфейсе клацают добавить в корзину. Когда я клацаю в интерфейсе добавить
// в корзину целый обьект этого товара доходит до вот этого метода add() и сюда будет 
// передаваться вот такой обьект cart.add({ name: 'apple', price: 50 });
// Помните что если справа от равно или при передаче аргумента это обьект это литерал
// обьекта. Тоесть я передаю туда прямо целиком какой-то обьект сейчас.
// Смотрим внутри на метод product - console.log(product); - вот в консоле показался наш 
// обьект
// И теперь я просто в корзину в пустой массив items: [], его пушу, тоесть пишу
// this.items.push(product);   и ещё раз посмотрю що там внутри console.table(cart.getItems());
// внутри теперь лежит один обьект в которого имя яблочко и цена 50.
// Кроме этого у нас обычно в корзине чё там есть? Там лежит не просто обьект а ещё в 
// обьекта есть сколько их в корзине лежит, можем что-то там добавить 2, 3, 10 , миллиард
// и можно ещё вниз это убрать, есть + и - кнопочки, типа нажымаеш + увеличивается количество
// в корзине, нажымаеш '-' уменшается количество в корзине и теперь тут в методе внутри
// add сделаю новое свойство quantity (количество) которому поставлю 1 ( product.quantity = 1;)
// это количество продукта который лежит в корзине, я прорсто на этот продукт его добавил и
// запушил в корзину


// {name: 'apple', price: 50}
// {name: 'grapes', price: 70}
// {name: 'lemon', price: 60}
// {name: 'strawberry', price: 110}

// const cart = {
//     items: [],
//     getItems() {
//         return this.items;
//     },
//     add(product) {
//         product.quantity = 1;
//         this.items.push(product);
//     }
// }

// console.table(cart.getItems());
// cart.add({ name: 'apple', price: 50 });

// console.table(cart.getItems());



// 3-тий метод remove(productName)  -  удаляем продукт из корзины.
// ТЕПЕРЬ будем удалять продукт из корзины (remove (удалять)) по имени, 
// (когда мы что то удаляем нам надо уникальный идентификатор, пока такое не учим, потому
// используем имя продукта нон у нас сейчас вобщем-то уникально)
// Давайте ещё что-то добавлю в корзину, сейчас добавлю туда лимончик cart.add({name: 'lemon', price: 60});
// Так удаляем что-то, я пишу cart.remove('apple') я пишу и хочу удалить это яблоко которое
// у меня было первым. Смотрим, да когда вызывается метод remove консолим в методе внутри
// console.log(productName); и получаем вот это яблоко в консоле. Тоесть яблоко хранится
// у этого свойства name у обьекта, что нам нужно? перебрать этот масив, найти этот обьект
// и на той итерации (помните метод splice он на каком-то индексе может удалить один
// элемент, тоесть я могу буквально сделать тоже самое), я перебираю массив и на том индексе 
// на котором я найду это яблоко я его сплайсну от туда (splice) вот и все/
// Пишем for (const item of this.items) { console.log(item);  if (productName === item.name) {
// Есть проблема, что-бы вызвать метод splice нам нужен индекс в котором его удалять
// for...of нам индекса не даёт, в даном случае нам нужен класический for что-бы получить
// доступ  к индексу


// const cart = {
//     items: [],
//     getItems() {
//         return this.items;
//     },
//     add(product) {
//         product.quantity = 1;
//         this.items.push(product);
//     },
//     remove(productName) {
//         console.log(productName);

//         for (const item of this.items) {
//             console.log(item);

//             if (productName === item.name) {
//                 console.log('Нашли!!!');
//             }
//         }
//     }
// };

// console.table(cart.getItems());
// cart.add({ name: 'apple', price: 50 });
// cart.add({name: 'lemon', price: 60});

// console.table(cart.getItems());
// cart.remove('apple');



// for...of нам индекса не даёт, в даном случае нам нужен класический for что-бы получить
// доступ  к индексу. Тоесть нам нужно написать for (let i = 0; i < this.items.length; i += 1)
// и тогда заместь вот этого  if (productName === item.name)  будет такое
//  if (productName === this.items[i].name) - мы обращаемся к массиву this.items берем у
// него с таким индексом [i] элемент, это будет вот такой обьект this.items[i] и у этого
// обьекта берем .name свойство
// Теперь что-бы вот такие вот магические вещи if (productName === this.items[i].name) 
// в for не писать, это ссылка this.items[i] на обьект просто выносим её в переменную
// что-бы понятно было что просиходит  const item = this.items[i];
// и тогда можем нормально написать if (productName === item.name)  и такой код будет 
// чуть чуть читабельнее.

// Супер нашли мы наше яблочко, теперь у нас есть доступ к индексу console.log(i); мы нашли
// его на нулевом индексе буквально и теперь мы вызываем просто splice - this.items.splice(i, 1);
// (i, 1): i - это с какого индекса начинать удалять и сколько удалять 1
// Потом внизу после cart.remove('apple'); консольнем что-бы посмотреть что получилось
// console.table(cart.getItems());

// const cart = {
//     items: [],
//     getItems() {
//         return this.items;
//     },
//     add(product) {
//         product.quantity = 1;
//         this.items.push(product);
//     },
//     remove(productName) {

//         for (let i = 0; i < this.items.length; i += 1) {
//             const item = this.items[i];

//             if (productName === item.name) {
//                 console.log('Нашли, удаляем!!!');
//                 console.log('Индекс для удаления: ', i);

//                 this.items.splice(i, 1);
//             }
//         }
//     }
// };

// console.table(cart.getItems());
// cart.add({ name: 'apple', price: 50 });
// cart.add({name: 'lemon', price: 60});

// console.table(cart.getItems());

// cart.remove('apple');
// console.table(cart.getItems());



// Можно один раз написать модуль корзины а потом на всех сайтах использовать у себя.
// (логика пишется руками, а потом используешь). Когда мы работаем типа как на WordPress
// там канешно есть уже за нас написан модуль корзины, ты просто подключаеш его и он
// работает, вообще когда ты работаеш с СMM-кой тебе и разработчиком быть не надо ты 
// можеш быть . Ворд пресс - это инструмент который позволяет быстро сайты делать как
// лего собирать (короче это фигня популярная).


// 4-тый метод clear() - это когда мы очищаем полностью корзину (в интерфейсе есть такая
// кнопка очистить корзину)  clear - чисто. 
// Что такое очистить корзину? Это полностью удалить из этого массива items: [] все
// элементы. Удалять их по одному не нужно 
// Тоесть когда я вызываю (remove пока что не буду вызывать) cart.clear(); то корзина 
// должна очистится.
// Есть несколько вариантов, там уже писали про length = 0 и так далее, можно сделать вот
// так вот this.items.length = 0;  значит вот это свойство length у массива оно ж динамическое
// и туда можно записывать (я говорил что на самом деле записывать туда нельзя, но не 
// потому что записывать туда запрещено языком, а потому что это не самая хорошая практика).
// Типа вот так вот  clear() {this.items.length = 0;  полностью очистится массив.


// НО ЛУЧШЕ вот в это свойство записать просто другой пустой массив this.items = []; -
// вот так лучше очищать.
// Тоесть если надо просто в этом свойстве что-то почистить - записываем туда ссылку на
// другой массив и не парится (this.items = [];), просто перезаписать значение пустым массивом

// В чем разница? Есть такие инструменты линтеры - это такие анализаторы кода которые 
// следуют ....  так вот если мы напишем так this.items.length = 123123; они это могут
// очень сильно подчеркивать, потому что свойство length желательно там (есть последствия
// под капотные там какие-то модные при работе с length руками когда ты его изменяеш 
// это типа неблагоприятно влияет  вобщем ну... долго обьяснять ) но лучше просто записать
// пустой массив и досвидания

// Как только мы записали в эту переменную this.items другой массив создается новое место
// в памяти под этот новый массив, а то место в памяти которое было очищается и как будто
// никогда не существовало

// const cart = {
//     items: [],
//     getItems() {
//         return this.items;
//     },
//     add(product) {
//         product.quantity = 1;
//         this.items.push(product);
//     },
//     remove(productName) {

//         for (let i = 0; i < this.items.length; i += 1) {
//             const item = this.items[i];

//             if (productName === item.name) {
//                 console.log('Нашли, удаляем!!!');
//                 console.log('Индекс для удаления: ', i);

//                 this.items.splice(i, 1);
//             }
//         }
//     },
//     clear() {
//         this.items = [];
// }
// };

// console.table(cart.getItems());
// cart.add({ name: 'apple', price: 50 });
// cart.add({name: 'lemon', price: 60});

// console.table(cart.getItems());

// cart.remove('apple');
// console.table(cart.getItems());

// cart.clear();
// console.table(cart.getItems());




// 5-тый метод countTotalPrice() ()
// countTotalPrice - подсчитать общую цену

// Вопрос? Нет ли заранее таких готовых свойств? Есть много библиотек всяких, которые мы
// будем потом смотреть что такое библиотека и так далее. То они уже за вас кое что 
// реализуют. Но на самом деле мы все это пишем ручками хотя бы один раз в своей жизни.
// Потому что Вам необходимо учится решать задачи, вам необходимо привыкать логически
// мыслить. Мы не можем просто как обезьянка с клавиатурой пойти и что-то использовать,
// потому что прийдёт тот уровень твоего развития когда ты просто упрёшся головой просто
// в стену и не сможеш пойти дальше и все.


// 5-тый метод countTotalPrice() который будет подсчитывать общую цену продуктов в корзине
// товаров. Он ничего не получает потому что все что ему нужно уже есть в этом обьекте 
// items: []  и он будет возвращать общую цену. Тут делаем класические вещи, мы проходимся
// по этим айтемам items: [], тоесть мы делаем как обычно переменную total (общее) и 
// будем возвращать результат return total;  (clear и remove убираем скрываем что-бы нам
// не машало) и выводим в консоль снизу console.log('Total: ', cart.countTotalPrice());
// Получается что мы в этом методе countTotalPrice() прохрдимся циклом по items: [],
// тоесть по этому массиву где уже 2 элемента есть, у каждого из них берем price и 
// умножаем на quantity и возвращаем значение. Смотрим for (const item of this.items) {
// и тут мы можем получить доступ к item (item - это у нас вот этот вот обьект items: [])
// у которого есть цена за штуку и количество штук в корзине. Тоесть total += мы берем
// item.price свойство у него есть умножыть на item.quantity ()  (total += item.price * item.quantity;)
// Тоесть мы берем цену за одну штуку умножаем на количество штук в корзине, получаем 
// результат и плюсуем это к total

// Опять таки как видите перебери массив обьекта и что сделай на каждой итерации
// Главное привыкнуть що на каждой итерации у нас есть доступ ко всем свойствам обьектов



// const cart = {
//     items: [],
//     getItems() {
//         return this.items;
//     },
//     add(product) {
//         product.quantity = 1;
//         this.items.push(product);
//     },
//     remove(productName) {

//         for (let i = 0; i < this.items.length; i += 1) {
//             const item = this.items[i];

//             if (productName === item.name) {
//                 console.log('Нашли, удаляем!!!');
//                 console.log('Индекс для удаления: ', i);

//                 this.items.splice(i, 1);
//             }
//         }
//     },
//     clear() {
//         this.items = [];
//     },
//     countTotalPrice() {
//         let total = 0;

//         for (const item of this.items) {
//             console.log(item);

//             total += item.price * item.quantity;
//         }

//         return total;
//     }
// };

// console.table(cart.getItems());
// cart.add({ name: 'apple', price: 50 });
// cart.add({name: 'lemon', price: 60});

// console.table(cart.getItems());

// // cart.remove('apple');
// // console.table(cart.getItems());

// // cart.clear();
// // console.table(cart.getItems());

// console.log('Total: ', cart.countTotalPrice());




// А если один продукт несколько раз в корзину добавили? Это когда мы нажали кнопку
// добавить продукт у нас в корзину добавилось это яблочко, а потом в том же месте 
// интерфейса ещё раз нажали добавить в корзину, то в нас естественно не должен добавится
// такой же самый, потому что мы добавили яблоко а потом ещё раз добавили яблоко и у нас
// сейчас будет 2 одинаковых обьекта. Вместо того что-бы увеличивать вот это свойство
// quantity мы добавили второй такой же обьект. Ну у нас такая логика у нас сейчас так 
// код написан. Соответственно, когда мы добавляем что-то (давайте так в будущем: когда
// вы что-то добавите в корзину у вас возможно в интерфейсе просто пропадет вот эта кнопка
// добавить и уже на карточке этого продукта будет 'уже в корзине' и там уже без кнопки
// будет). Но тем не менее если эта кнопка там отсаётся как это сделать?: 

// Мы можем просто во время добавления add(product) {} проверить если обьект с таким 
// именем уже есть в массиве мы просто увеличичваем его quantity, если нету тогда его 
// добавим. Тоесть прямо вот здесь add(product) {
// },                                  мы делаем опять же перебор целого массива.
// Это пока убираем //     product.quantity = 1;
//     this.items.push(product);
// 
// В методе add() перебираем наш  items, смотрим в консоль  console.log(item);
// Теперь у нас есть продукт product который мы передали это тоже вот такой обьект с name
// cart.add({ name: 'apple', price: 50 });
// Мы говорим если в том продукте который передали такое же имя как в этом item
// if(item.name === product.name)  -  это значит что такой продукт уже у нас в 
// корзине есть, мы его сразу нашли в нашей корзине.
// В таком случае если в  items: [ есть такой обьект нам его не нужно пушить нам нужно
// просто у этого item увеличить quantity на 1. Мы  пишем item.quantity += 1; тоесть
// на 1 просто увеличиваем и выходим из этой функции return, все больше мы ничего не делаем.
// 
// Ещё раз: перебираем все продукты которые у нас есть сейчас в items: [  смотрим если 
// у какого-то айтема имя совпадает с именем продукта которого передали то такое уже 
// есть и вы просто у текущего item , так как это ссылка (item это ссылка на обьект ) и 
// пишем туда новое значение и мы увеличиваем на 1. Получается каждый раз когда я буду
// добавлять cart.add({ name: 'apple', price: 50 }); оно мне 2 раза скажет що такой продукт
// есть и я врезультате увижу 3 quantity.
// Как только я добавлю туда лимончик (уберем лимончик с items:) и добавим снизу так
// cart.add({ name: 'lemon', price: 60 });  Лимончик нам не добавился потому что у меня 
// сейчас нет логики, почему на лимон ничего не произошло? потому что у меня идет выход из
// функции return; и ничего не происходит.
// Так вот если во время этого for в методе add() мы не нашли такой продукт в корзине,
// вот тогда мы начинаем его quantity (добавлять количество) с 1 и пушим. 
// product.quantity = 1;
//     this.items.push(product);    и у нас появляется в корзине 1 лимончик.
// Когда мы добавляли яблоки он уже был, в начале наш массив items: [{ name: 'apple', price: 50, quantity: 1 },
// и мы увеличиваем, а когда мы увидели что пришол лимончик вот здесь снизу при добавлении
// cart.add({ name: 'lemon', price: 60 });  то мы сказали что это новый продукт у нас 
// такого нету и мы его добавили в корзину с quantity = 1;


// const cart = {
//     items: [
//         { name: 'apple', price: 50, quantity: 1 },
//     ],
//     getItems() {
//         return this.items;
//     },
//     add(product) {
//         for (const item of this.items) {
//             console.log(item);

//             if (item.name === product.name) {
//                 console.log('Такой продукт уже есть, увеличиваем количество!!!');
//                 item.quantity += 1;
//                 return;
//             }
//         }
//         console.log('Новый продукт, добавляем в корзину');
//         product.quantity = 1;
//         this.items.push(product);
//     },
//     remove(productName) {

//         for (let i = 0; i < this.items.length; i += 1) {
//             const item = this.items[i];

//             if (productName === item.name) {
//                 console.log('Нашли, удаляем!!!');
//                 console.log('Индекс для удаления: ', i);

//                 this.items.splice(i, 1);
//             }
//         }
//     },
//     clear() {
//         this.items = [];
//     },
//     countTotalPrice() {
//         let total = 0;

//         for (const item of this.items) {
//             // console.log(item);

//             total += item.price * item.quantity;
//         }

//         return total;
//     }
// };

// console.table(cart.getItems());
// cart.add({ name: 'apple', price: 50 });
// cart.add({ name: 'apple', price: 50 });
// cart.add({ name: 'lemon', price: 60 });
// // cart.add({ name: 'apple', price: 50 });

// console.table(cart.getItems());

// // cart.remove('apple');
// // console.table(cart.getItems());

// // cart.clear();
// // console.table(cart.getItems());

// console.log('Total: ', cart.countTotalPrice());




// Ну и на последок: это вот что происходит напротив продукта напротив его количества
// есть 2 кнопки увеличить уменьшить + и - вот вы на них клацпете и увеличиваетрся вот
// эта часть quantity (количество). И при чем когда вы доходите до нуля удаляется 
// продукт из корзины, сейчас это посмотрим


// 6-той метод increaseQuantity(productName)
// increaseQuantity - увеличить количество

// Это можна сделать одним абгрейд Quantity или как-то пару параметром передать, это 
// будет довольно сложный код, поэтому я сейчас сделаю разными, потом наберетесь опыта 
// немножко и сделаем одним.

// Вот у меня метод increaseQuantity(productName), вот наш productName просто имя продукта
// quantity (количество) которого я хочу увеличить. Соответственно мне нужно найти этот
// продукт в массиве и  у него увеличить свойство quantity. Перебираем наш items: 
// for (const item of this.items) {
// Потом вызываем имя продукта apple - cart.increaseQuantity('apple');
// Потом сравниваем если item   if (item.name === productName) {  и нашло яблоко потому что
// мы записали яблоко при вызове метода cart.increaseQuantity('apple');
// если мы запишем лимончик то нам найдет лимончик 
// Если я нажал + quantity, нажали +, надо пойти у этого item его quantity увеличить на 1.
// Потом ещё раз выводим console.table(cart.getItems());



/*  
const cart = {
    items: [
        { name: 'apple', price: 50, quantity: 1 },
    ],
    getItems() {
        return this.items;
    },
    add(product) {
        for (const item of this.items) {
            console.log(item);

            if (item.name === product.name) {
                console.log('Такой продукт уже есть, увеличиваем количество!!!');
                item.quantity += 1;
                return;
            }
        }
        console.log('Новый продукт, добавляем в корзину');
        product.quantity = 1;
        this.items.push(product);
    },
    remove(productName) {

        for (let i = 0; i < this.items.length; i += 1) {
            const item = this.items[i];

            if (productName === item.name) {
                console.log('Нашли, удаляем!!!');
                console.log('Индекс для удаления: ', i);

                this.items.splice(i, 1);
            }
        }
    },
    clear() {
        this.items = [];
    },
    countTotalPrice() {
        let total = 0;

        for (const item of this.items) {
            // console.log(item);

            total += item.price * item.quantity;
        }

        return total;
    },
    increaseQuantity(productName) {
        for (const item of this.items) {
            if (item.name === productName) {
                item.quantity += 1;
            }
        }
    },
    decreaseQuantity(productName) {
        for (const item of this.items) {
            if (item.name === productName) {
                if (item.quantity - 1 === 0) {
                    this.remove(productName);
                    return;
                }
                item.quantity -= 1;
            }
        }
    }
};

console.table(cart.getItems());
cart.add({ name: 'apple', price: 50 });
cart.add({ name: 'apple', price: 50 });
cart.add({ name: 'lemon', price: 60 });
// cart.add({ name: 'apple', price: 50 });

console.table(cart.getItems());

// cart.remove('apple');
// console.table(cart.getItems());

// cart.clear();
// console.table(cart.getItems());

cart.increaseQuantity('apple');
console.table(cart.getItems());

cart.decreaseQuantity('lemon');
console.table(cart.getItems());
console.log('Total: ', cart.countTotalPrice());
*/




// 7-мой метод decreaseQuantity(productName) - уменьшить количество, делаем то же самое,
// можно обьединить но код будет немножко сложнее пока 2-ма методами делаем
// То же самое, проходим по массиву циклом, ищем совпадение с item.name === productName
// и делаем минус 1 (item.quantity -= 1;)
// И вызываем decreaseQuantity  минусуем лимончик и есть проблема , когда нажымаем минус в
// корзине,у нас есть 1 item, мы нажымаем минус, он не просто сбрасывается в ноль он просто
// удаляется из корзины полностью. Вот эта вот строка с продуктом из корзины удаляется 
// когда менше одного.
// Нам тоже это нужно реализовать, что когда у нас quantity (если бы отняв единицу от 
// текущего quantity у нас бы остался ноль,, нам нужно вот этот элемент изьять из массива 
// полностью)
// Смотрите какая штука, ставим дополнительную проверку в decreaseQuantity, проверка если
// if (item.quantity - 1 === 0) {
                    // this.remove(productName);   -   удаляем методом remove (удалять)
                    // return;       -   и выходим из метода из функции

// Если этот иф не выполнился if (item.quantity - 1 === 0)  тоесть item.quantity - 1 > 0
// то я просто беру и делаю минус один значение item.quantity -= 1;

// ВСЕ!  МЫ СДЕЛАЛИ КОРЗИНУ ТОВАРОВ, склад товаров, ещё что-то - это все обьекты с методами
// 



// На самом деле вот так вот устроены все данные в настоящих приложениях - у вас есть какой
// -то обьект и методы (и свойства на обьекте хранить данные) для изменения этого свойства

// const cart = {
//     items: [
//         { name: 'apple', price: 50, quantity: 1 },
//     ],
//     getItems() {
//         return this.items;
//     },
//     add(product) {
//         for (const item of this.items) {
//             console.log(item);

//             if (item.name === product.name) {
//                 console.log('Такой продукт уже есть, увеличиваем количество!!!');
//                 item.quantity += 1;
//                 return;
//             }
//         }
//         console.log('Новый продукт, добавляем в корзину');
//         product.quantity = 1;
//         this.items.push(product);
//     },
//     remove(productName) {

//         for (let i = 0; i < this.items.length; i += 1) {
//             const item = this.items[i];

//             if (productName === item.name) {
//                 console.log('Нашли, удаляем!!!');
//                 console.log('Индекс для удаления: ', i);

//                 this.items.splice(i, 1);
//             }
//         }
//     },
//     clear() {
//         this.items = [];
//     },
//     countTotalPrice() {
//         let total = 0;

//         for (const item of this.items) {
//             // console.log(item);

//             total += item.price * item.quantity;
//         }

//         return total;
//     },
//     increaseQuantity(productName) {
//         for (const item of this.items) {
//             if (item.name === productName) {
//                 item.quantity += 1;
//             }
//         }
//     },
//     decreaseQuantity(productName) {
//         for (const item of this.items) {
//             if (item.name === productName) {
//                 if (item.quantity - 1 === 0) {
//                     this.remove(productName);
//                     return;
//                 }
//                 item.quantity -= 1;
//             }
//         }
//     }
// };

// document.querySelector('.js-show-cart').addEventListener('click', () => {
//     console.table(cart.getItems());
// })

// document
//     .querySelector('button[data-product="apple"]')
//     .addEventListener('click', cart.add.bind(cart, { name: 'apple', price: 50 }));



// Зачем мы это писали и где все эти методы потом будут юзатся.
// Вот мы сделали этот обьект cart, у нас будет интерфейс типа (Показать содержимое корзины)
// Теперь берем эту кнопку и вешаем на неё слушателя собития на click
/* document.querySelector('.js-show-cart').addEventListener('click', () => {
    console.table(cart.getItems());
})    -   нажымаем на кнопку и мы получаем содержимое нашей корзины.



Вото то что мы с Вами сверху написали обьект кард - это называется модель или данные которые
естественно управляют подкапотной логикой при кликах при событиях в интерфейсе.
ЭТО называется модель

Потом вот это называется view или отображение - это непосредственно какой-то код который 
работает с интерфейсом, отслеживает вот эти клики всякие и т.д. и вызывает методы из
Вашей модели из корзины с логикой.
(document.querySelector('.js-show-cart').addEventListener('click', () => {
    console.table(cart.getItems());
}))


Вот так это работает, тоесть ты отдельно пишеш работу с данными, а отдельно пишеш код 
который отвечает за отрисовку этого всего. И он получается так: ты кликнул, оно из той
модели данных у тебя что-то вызвало получило в этот код и нарисовало. У нас рисует
сейчас в консоль но тем не менее.

Допустим если я сделаю кнопку добавить яблоко и потом на него повешу слушателя клик и
при клике на кнопку добавить яблоко будет добавлятся в корзину { name: 'apple', price: 50 }
увеличиватся количество яблок в корзине.

Мы написали работу с моделлю работу с данными, а потом когда мы привыкнем работать с данными
мы привыкнем манипулировать вот этими массивами обьекта мы начнем баловатся вот этими 
кнопочками кликами и отображением этой всей красоты

Важное - модель cart, а код работающий с интерфейсом любой вася сделает
*/




// Для того что-бы сделать уникальный идентификатор используются готовые пакете.
// Вопше id-шники делаются на бекенде, просто пока бекенда у нас нет мы не умеем с ним 
// работать, можно использовать какие-то пакетики для генерации. Пакетики мы тоже не 
// умеем ставить поэтому мы от фонаря используем бит рандомную строку.
// Id-шники делаются на бекенде когда создается обьект в базе данных, база даных сама 
// присвает ему уникальный идентификатор